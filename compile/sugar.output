Conflict in state 51 between rule 58 and token OR resolved as reduce.
Conflict in state 51 between rule 58 and token AND resolved as reduce.
Conflict in state 51 between rule 58 and token EQ resolved as reduce.
Conflict in state 51 between rule 58 and token NEQ resolved as reduce.
Conflict in state 51 between rule 58 and token GT resolved as reduce.
Conflict in state 51 between rule 58 and token LT resolved as reduce.
Conflict in state 51 between rule 58 and token GEQ resolved as reduce.
Conflict in state 51 between rule 58 and token LEQ resolved as reduce.
Conflict in state 51 between rule 58 and token '-' resolved as reduce.
Conflict in state 51 between rule 58 and token '+' resolved as reduce.
Conflict in state 51 between rule 58 and token '*' resolved as reduce.
Conflict in state 51 between rule 58 and token '/' resolved as reduce.
Conflict in state 51 between rule 58 and token '^' resolved as shift.
Conflict in state 53 between rule 57 and token OR resolved as reduce.
Conflict in state 53 between rule 57 and token AND resolved as reduce.
Conflict in state 53 between rule 57 and token EQ resolved as reduce.
Conflict in state 53 between rule 57 and token NEQ resolved as reduce.
Conflict in state 53 between rule 57 and token GT resolved as reduce.
Conflict in state 53 between rule 57 and token LT resolved as reduce.
Conflict in state 53 between rule 57 and token GEQ resolved as reduce.
Conflict in state 53 between rule 57 and token LEQ resolved as reduce.
Conflict in state 53 between rule 57 and token '-' resolved as reduce.
Conflict in state 53 between rule 57 and token '+' resolved as reduce.
Conflict in state 53 between rule 57 and token '*' resolved as reduce.
Conflict in state 53 between rule 57 and token '/' resolved as reduce.
Conflict in state 53 between rule 57 and token '^' resolved as shift.
Conflict in state 87 between rule 60 and token OR resolved as reduce.
Conflict in state 87 between rule 60 and token AND resolved as shift.
Conflict in state 87 between rule 60 and token EQ resolved as shift.
Conflict in state 87 between rule 60 and token NEQ resolved as shift.
Conflict in state 87 between rule 60 and token GT resolved as shift.
Conflict in state 87 between rule 60 and token LT resolved as shift.
Conflict in state 87 between rule 60 and token GEQ resolved as shift.
Conflict in state 87 between rule 60 and token LEQ resolved as shift.
Conflict in state 87 between rule 60 and token '-' resolved as shift.
Conflict in state 87 between rule 60 and token '+' resolved as shift.
Conflict in state 87 between rule 60 and token '*' resolved as shift.
Conflict in state 87 between rule 60 and token '/' resolved as shift.
Conflict in state 87 between rule 60 and token '^' resolved as shift.
Conflict in state 88 between rule 59 and token OR resolved as reduce.
Conflict in state 88 between rule 59 and token AND resolved as reduce.
Conflict in state 88 between rule 59 and token EQ resolved as shift.
Conflict in state 88 between rule 59 and token NEQ resolved as shift.
Conflict in state 88 between rule 59 and token GT resolved as shift.
Conflict in state 88 between rule 59 and token LT resolved as shift.
Conflict in state 88 between rule 59 and token GEQ resolved as shift.
Conflict in state 88 between rule 59 and token LEQ resolved as shift.
Conflict in state 88 between rule 59 and token '-' resolved as shift.
Conflict in state 88 between rule 59 and token '+' resolved as shift.
Conflict in state 88 between rule 59 and token '*' resolved as shift.
Conflict in state 88 between rule 59 and token '/' resolved as shift.
Conflict in state 88 between rule 59 and token '^' resolved as shift.
Conflict in state 89 between rule 61 and token OR resolved as reduce.
Conflict in state 89 between rule 61 and token AND resolved as reduce.
Conflict in state 89 between rule 61 and token EQ resolved as reduce.
Conflict in state 89 between rule 61 and token NEQ resolved as reduce.
Conflict in state 89 between rule 61 and token GT resolved as reduce.
Conflict in state 89 between rule 61 and token LT resolved as reduce.
Conflict in state 89 between rule 61 and token GEQ resolved as reduce.
Conflict in state 89 between rule 61 and token LEQ resolved as reduce.
Conflict in state 89 between rule 61 and token '-' resolved as shift.
Conflict in state 89 between rule 61 and token '+' resolved as shift.
Conflict in state 89 between rule 61 and token '*' resolved as shift.
Conflict in state 89 between rule 61 and token '/' resolved as shift.
Conflict in state 89 between rule 61 and token '^' resolved as shift.
Conflict in state 90 between rule 62 and token OR resolved as reduce.
Conflict in state 90 between rule 62 and token AND resolved as reduce.
Conflict in state 90 between rule 62 and token EQ resolved as reduce.
Conflict in state 90 between rule 62 and token NEQ resolved as reduce.
Conflict in state 90 between rule 62 and token GT resolved as reduce.
Conflict in state 90 between rule 62 and token LT resolved as reduce.
Conflict in state 90 between rule 62 and token GEQ resolved as reduce.
Conflict in state 90 between rule 62 and token LEQ resolved as reduce.
Conflict in state 90 between rule 62 and token '-' resolved as shift.
Conflict in state 90 between rule 62 and token '+' resolved as shift.
Conflict in state 90 between rule 62 and token '*' resolved as shift.
Conflict in state 90 between rule 62 and token '/' resolved as shift.
Conflict in state 90 between rule 62 and token '^' resolved as shift.
Conflict in state 91 between rule 63 and token OR resolved as reduce.
Conflict in state 91 between rule 63 and token AND resolved as reduce.
Conflict in state 91 between rule 63 and token EQ resolved as reduce.
Conflict in state 91 between rule 63 and token NEQ resolved as reduce.
Conflict in state 91 between rule 63 and token GT resolved as reduce.
Conflict in state 91 between rule 63 and token LT resolved as reduce.
Conflict in state 91 between rule 63 and token GEQ resolved as reduce.
Conflict in state 91 between rule 63 and token LEQ resolved as reduce.
Conflict in state 91 between rule 63 and token '-' resolved as shift.
Conflict in state 91 between rule 63 and token '+' resolved as shift.
Conflict in state 91 between rule 63 and token '*' resolved as shift.
Conflict in state 91 between rule 63 and token '/' resolved as shift.
Conflict in state 91 between rule 63 and token '^' resolved as shift.
Conflict in state 92 between rule 64 and token OR resolved as reduce.
Conflict in state 92 between rule 64 and token AND resolved as reduce.
Conflict in state 92 between rule 64 and token EQ resolved as reduce.
Conflict in state 92 between rule 64 and token NEQ resolved as reduce.
Conflict in state 92 between rule 64 and token GT resolved as reduce.
Conflict in state 92 between rule 64 and token LT resolved as reduce.
Conflict in state 92 between rule 64 and token GEQ resolved as reduce.
Conflict in state 92 between rule 64 and token LEQ resolved as reduce.
Conflict in state 92 between rule 64 and token '-' resolved as shift.
Conflict in state 92 between rule 64 and token '+' resolved as shift.
Conflict in state 92 between rule 64 and token '*' resolved as shift.
Conflict in state 92 between rule 64 and token '/' resolved as shift.
Conflict in state 92 between rule 64 and token '^' resolved as shift.
Conflict in state 93 between rule 65 and token OR resolved as reduce.
Conflict in state 93 between rule 65 and token AND resolved as reduce.
Conflict in state 93 between rule 65 and token EQ resolved as reduce.
Conflict in state 93 between rule 65 and token NEQ resolved as reduce.
Conflict in state 93 between rule 65 and token GT resolved as reduce.
Conflict in state 93 between rule 65 and token LT resolved as reduce.
Conflict in state 93 between rule 65 and token GEQ resolved as reduce.
Conflict in state 93 between rule 65 and token LEQ resolved as reduce.
Conflict in state 93 between rule 65 and token '-' resolved as shift.
Conflict in state 93 between rule 65 and token '+' resolved as shift.
Conflict in state 93 between rule 65 and token '*' resolved as shift.
Conflict in state 93 between rule 65 and token '/' resolved as shift.
Conflict in state 93 between rule 65 and token '^' resolved as shift.
Conflict in state 94 between rule 66 and token OR resolved as reduce.
Conflict in state 94 between rule 66 and token AND resolved as reduce.
Conflict in state 94 between rule 66 and token EQ resolved as reduce.
Conflict in state 94 between rule 66 and token NEQ resolved as reduce.
Conflict in state 94 between rule 66 and token GT resolved as reduce.
Conflict in state 94 between rule 66 and token LT resolved as reduce.
Conflict in state 94 between rule 66 and token GEQ resolved as reduce.
Conflict in state 94 between rule 66 and token LEQ resolved as reduce.
Conflict in state 94 between rule 66 and token '-' resolved as shift.
Conflict in state 94 between rule 66 and token '+' resolved as shift.
Conflict in state 94 between rule 66 and token '*' resolved as shift.
Conflict in state 94 between rule 66 and token '/' resolved as shift.
Conflict in state 94 between rule 66 and token '^' resolved as shift.
Conflict in state 95 between rule 53 and token OR resolved as reduce.
Conflict in state 95 between rule 53 and token AND resolved as reduce.
Conflict in state 95 between rule 53 and token EQ resolved as reduce.
Conflict in state 95 between rule 53 and token NEQ resolved as reduce.
Conflict in state 95 between rule 53 and token GT resolved as reduce.
Conflict in state 95 between rule 53 and token LT resolved as reduce.
Conflict in state 95 between rule 53 and token GEQ resolved as reduce.
Conflict in state 95 between rule 53 and token LEQ resolved as reduce.
Conflict in state 95 between rule 53 and token '-' resolved as reduce.
Conflict in state 95 between rule 53 and token '+' resolved as reduce.
Conflict in state 95 between rule 53 and token '*' resolved as shift.
Conflict in state 95 between rule 53 and token '/' resolved as shift.
Conflict in state 95 between rule 53 and token '^' resolved as shift.
Conflict in state 96 between rule 52 and token OR resolved as reduce.
Conflict in state 96 between rule 52 and token AND resolved as reduce.
Conflict in state 96 between rule 52 and token EQ resolved as reduce.
Conflict in state 96 between rule 52 and token NEQ resolved as reduce.
Conflict in state 96 between rule 52 and token GT resolved as reduce.
Conflict in state 96 between rule 52 and token LT resolved as reduce.
Conflict in state 96 between rule 52 and token GEQ resolved as reduce.
Conflict in state 96 between rule 52 and token LEQ resolved as reduce.
Conflict in state 96 between rule 52 and token '-' resolved as reduce.
Conflict in state 96 between rule 52 and token '+' resolved as reduce.
Conflict in state 96 between rule 52 and token '*' resolved as shift.
Conflict in state 96 between rule 52 and token '/' resolved as shift.
Conflict in state 96 between rule 52 and token '^' resolved as shift.
Conflict in state 97 between rule 54 and token OR resolved as reduce.
Conflict in state 97 between rule 54 and token AND resolved as reduce.
Conflict in state 97 between rule 54 and token EQ resolved as reduce.
Conflict in state 97 between rule 54 and token NEQ resolved as reduce.
Conflict in state 97 between rule 54 and token GT resolved as reduce.
Conflict in state 97 between rule 54 and token LT resolved as reduce.
Conflict in state 97 between rule 54 and token GEQ resolved as reduce.
Conflict in state 97 between rule 54 and token LEQ resolved as reduce.
Conflict in state 97 between rule 54 and token '-' resolved as reduce.
Conflict in state 97 between rule 54 and token '+' resolved as reduce.
Conflict in state 97 between rule 54 and token '*' resolved as reduce.
Conflict in state 97 between rule 54 and token '/' resolved as reduce.
Conflict in state 97 between rule 54 and token '^' resolved as shift.
Conflict in state 98 between rule 55 and token OR resolved as reduce.
Conflict in state 98 between rule 55 and token AND resolved as reduce.
Conflict in state 98 between rule 55 and token EQ resolved as reduce.
Conflict in state 98 between rule 55 and token NEQ resolved as reduce.
Conflict in state 98 between rule 55 and token GT resolved as reduce.
Conflict in state 98 between rule 55 and token LT resolved as reduce.
Conflict in state 98 between rule 55 and token GEQ resolved as reduce.
Conflict in state 98 between rule 55 and token LEQ resolved as reduce.
Conflict in state 98 between rule 55 and token '-' resolved as reduce.
Conflict in state 98 between rule 55 and token '+' resolved as reduce.
Conflict in state 98 between rule 55 and token '*' resolved as reduce.
Conflict in state 98 between rule 55 and token '/' resolved as reduce.
Conflict in state 98 between rule 55 and token '^' resolved as shift.
Conflict in state 99 between rule 56 and token OR resolved as reduce.
Conflict in state 99 between rule 56 and token AND resolved as reduce.
Conflict in state 99 between rule 56 and token EQ resolved as reduce.
Conflict in state 99 between rule 56 and token NEQ resolved as reduce.
Conflict in state 99 between rule 56 and token GT resolved as reduce.
Conflict in state 99 between rule 56 and token LT resolved as reduce.
Conflict in state 99 between rule 56 and token GEQ resolved as reduce.
Conflict in state 99 between rule 56 and token LEQ resolved as reduce.
Conflict in state 99 between rule 56 and token '-' resolved as reduce.
Conflict in state 99 between rule 56 and token '+' resolved as reduce.
Conflict in state 99 between rule 56 and token '*' resolved as reduce.
Conflict in state 99 between rule 56 and token '/' resolved as reduce.
Conflict in state 99 between rule 56 and token '^' resolved as reduce.
State 68 contains 1 shift/reduce conflict.

Grammar
rule 1    netlist -> netlistDefs
rule 2    netlistDefs -> netlistDefs netlistDef
rule 3    netlistDefs -> netlistDef
rule 4    netlistDef -> paramLine
rule 5    netlistDef -> processLine
rule 6    netlistDef -> subnet
rule 7    netlistDef -> codeLine
rule 8    paramLine -> PARAM paramList
rule 9    paramList -> param
rule 10   paramList -> paramList ',' param
rule 11   param -> def
rule 12   param -> ID
rule 13   processLine -> PROCESS ID '=' blockStart defs blockEnd
rule 14   processLine -> PROCESS ID ':' ID '=' blockStart defs blockEnd
rule 15   subnet -> subnetHead codeBlock
rule 16   subnetHead -> subnetKey ID '[' names ']' '[' subnetParams ']'
rule 17   subnetKey -> SUBNET
rule 18   subnetParams -> subnetParams subnetParam
rule 19   subnetParams ->		/* empty */
rule 20   subnetParam -> def
rule 21   subnetParam -> ID '=' '*'
rule 22   subnetParam -> ID '=' '?'
rule 23   codeLines -> codeLines codeLine
rule 24   codeLines ->		/* empty */
rule 25   codeLine -> codeBlock
rule 26   codeLine -> def
rule 27   codeLine -> elementLine
rule 28   codeLine -> forLine
rule 29   codeLine -> ifLine
rule 30   codeLine -> callNode
rule 31   codeBlock -> blockStart codeLines blockEnd
rule 32   blockStart -> '['
rule 33   blockEnd -> ']'
rule 34   elementLine -> elementHead '[' names ']' blockStart defs blockEnd
rule 35   elementHead -> ID '(' exprs ')' ID ID
rule 36   elementHead -> ID ID ID
rule 37   elementHead -> ID '(' exprs ')' ID '*'
rule 38   elementHead -> ID ID '*'
rule 39   elementHead -> ID ID
rule 40   elementHead -> ID '*'
rule 41   forLine -> forHead codeBlock
rule 42   forHead -> FOR ID '=' expr ':' expr
rule 43   ifLine -> IF expr codeLine
rule 44   ifLine -> IF expr codeLine ELSE codeLine
rule 45   def -> ID '=' expr
rule 46   defs -> defs def
rule 47   defs ->		/* empty */
rule 48   names -> names name
rule 49   names ->		/* empty */
rule 50   name -> ID
rule 51   name -> ID '(' exprs ')'
rule 52   expr -> expr '+' expr
rule 53   expr -> expr '-' expr
rule 54   expr -> expr '*' expr
rule 55   expr -> expr '/' expr
rule 56   expr -> expr '^' expr
rule 57   expr -> '-' expr
rule 58   expr -> NOT expr
rule 59   expr -> expr AND expr
rule 60   expr -> expr OR expr
rule 61   expr -> expr EQ expr
rule 62   expr -> expr NEQ expr
rule 63   expr -> expr GT expr
rule 64   expr -> expr LT expr
rule 65   expr -> expr GEQ expr
rule 66   expr -> expr LEQ expr
rule 67   expr -> '(' expr ')'
rule 68   expr -> INT
rule 69   expr -> FLOAT
rule 70   expr -> STRING
rule 71   expr -> ID
rule 72   expr -> ID '(' optexprs ')'
rule 73   callNode -> CALL ID '(' optexprs ')'
rule 74   exprs -> exprs ',' expr
rule 75   exprs -> expr
rule 76   optexprs -> exprs
rule 77   optexprs ->		/* empty */

Terminals, with rules where they appear

$ (-1)
'(' (40) 35 37 51 67 72 73
')' (41) 35 37 51 67 72 73
'*' (42) 21 37 38 40 54
'+' (43) 52
',' (44) 10 74
'-' (45) 53 57
'/' (47) 55
':' (58) 14 42
'=' (61) 13 14 21 22 42 45
'?' (63) 22
'[' (91) 16 32 34
']' (93) 16 33 34
'^' (94) 56
error (256)
IF (257) 43 44
ELSE (258) 44
OR (259) 60
AND (260) 59
EQ (261) 61
NEQ (262) 62
GT (263) 63
LT (264) 64
GEQ (265) 65
LEQ (266) 66
NOT (267) 58
CALL (268) 73
SUBNET (269) 17
PARAM (270) 8
PROCESS (271) 13 14
FOR (272) 42
ID (273) 12 13 14 16 21 22 35 36 37 38 39 40 42 45 50 51 71 72 73
INT (274) 68
FLOAT (275) 69
STRING (276) 70
UMINUS (277)

Nonterminals, with rules where they appear

netlist (37)
    on left: 1
netlistDefs (38)
    on left: 2 3, on right: 1 2
netlistDef (39)
    on left: 4 5 6 7, on right: 2 3
paramLine (40)
    on left: 8, on right: 4
paramList (41)
    on left: 9 10, on right: 8 10
param (42)
    on left: 11 12, on right: 9 10
processLine (43)
    on left: 13 14, on right: 5
subnet (44)
    on left: 15, on right: 6
subnetHead (45)
    on left: 16, on right: 15
subnetKey (46)
    on left: 17, on right: 16
subnetParams (47)
    on left: 18 19, on right: 16 18
subnetParam (48)
    on left: 20 21 22, on right: 18
codeLines (49)
    on left: 23 24, on right: 23 31
codeLine (50)
    on left: 25 26 27 28 29 30, on right: 7 23 43 44
codeBlock (51)
    on left: 31, on right: 15 25 41
blockStart (52)
    on left: 32, on right: 13 14 31 34
blockEnd (53)
    on left: 33, on right: 13 14 31 34
elementLine (54)
    on left: 34, on right: 27
elementHead (55)
    on left: 35 36 37 38 39 40, on right: 34
forLine (56)
    on left: 41, on right: 28
forHead (57)
    on left: 42, on right: 41
ifLine (58)
    on left: 43 44, on right: 29
def (59)
    on left: 45, on right: 11 20 26 46
defs (60)
    on left: 46 47, on right: 13 14 34 46
names (61)
    on left: 48 49, on right: 16 34 48
name (62)
    on left: 50 51, on right: 48
expr (63)
    on left: 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69
    70 71 72, on right: 42 43 44 45 52 53 54 55 56 57 58 59 60 61 62
    63 64 65 66 67 74 75
callNode (64)
    on left: 73, on right: 30
exprs (65)
    on left: 74 75, on right: 35 37 51 74 76
optexprs (66)
    on left: 76 77, on right: 72 73


state 0

    IF  	shift, and go to state 1
    CALL	shift, and go to state 2
    SUBNET	shift, and go to state 3
    PARAM	shift, and go to state 4
    PROCESS	shift, and go to state 5
    FOR 	shift, and go to state 6
    ID  	shift, and go to state 7
    '[' 	shift, and go to state 8

    netlist	go to state 145
    netlistDefs	go to state 9
    netlistDef	go to state 10
    paramLine	go to state 11
    processLine	go to state 12
    subnet	go to state 13
    subnetHead	go to state 14
    subnetKey	go to state 15
    codeLine	go to state 16
    codeBlock	go to state 17
    blockStart	go to state 18
    elementLine	go to state 19
    elementHead	go to state 20
    forLine	go to state 21
    forHead	go to state 22
    ifLine	go to state 23
    def 	go to state 24
    callNode	go to state 25



state 1

    ifLine  ->  IF . expr codeLine   (rule 43)
    ifLine  ->  IF . expr codeLine ELSE codeLine   (rule 44)

    NOT 	shift, and go to state 26
    ID  	shift, and go to state 27
    INT 	shift, and go to state 28
    FLOAT	shift, and go to state 29
    STRING	shift, and go to state 30
    '-' 	shift, and go to state 31
    '(' 	shift, and go to state 32

    expr	go to state 33



state 2

    callNode  ->  CALL . ID '(' optexprs ')'   (rule 73)

    ID  	shift, and go to state 34



state 3

    subnetKey  ->  SUBNET .   (rule 17)

    $default	reduce using rule 17 (subnetKey)



state 4

    paramLine  ->  PARAM . paramList   (rule 8)

    ID  	shift, and go to state 35

    paramList	go to state 36
    param	go to state 37
    def 	go to state 38



state 5

    processLine  ->  PROCESS . ID '=' blockStart defs blockEnd   (rule 13)
    processLine  ->  PROCESS . ID ':' ID '=' blockStart defs blockEnd   (rule 14)

    ID  	shift, and go to state 39



state 6

    forHead  ->  FOR . ID '=' expr ':' expr   (rule 42)

    ID  	shift, and go to state 40



state 7

    elementHead  ->  ID . '(' exprs ')' ID ID   (rule 35)
    elementHead  ->  ID . ID ID   (rule 36)
    elementHead  ->  ID . '(' exprs ')' ID '*'   (rule 37)
    elementHead  ->  ID . ID '*'   (rule 38)
    elementHead  ->  ID . ID   (rule 39)
    elementHead  ->  ID . '*'   (rule 40)
    def  ->  ID . '=' expr   (rule 45)

    ID  	shift, and go to state 41
    '*' 	shift, and go to state 42
    '=' 	shift, and go to state 43
    '(' 	shift, and go to state 44



state 8

    blockStart  ->  '[' .   (rule 32)

    $default	reduce using rule 32 (blockStart)



state 9

    netlist  ->  netlistDefs .   (rule 1)
    netlistDefs  ->  netlistDefs . netlistDef   (rule 2)

    IF  	shift, and go to state 1
    CALL	shift, and go to state 2
    SUBNET	shift, and go to state 3
    PARAM	shift, and go to state 4
    PROCESS	shift, and go to state 5
    FOR 	shift, and go to state 6
    ID  	shift, and go to state 7
    '[' 	shift, and go to state 8

    $default	reduce using rule 1 (netlist)

    netlistDef	go to state 45
    paramLine	go to state 11
    processLine	go to state 12
    subnet	go to state 13
    subnetHead	go to state 14
    subnetKey	go to state 15
    codeLine	go to state 16
    codeBlock	go to state 17
    blockStart	go to state 18
    elementLine	go to state 19
    elementHead	go to state 20
    forLine	go to state 21
    forHead	go to state 22
    ifLine	go to state 23
    def 	go to state 24
    callNode	go to state 25



state 10

    netlistDefs  ->  netlistDef .   (rule 3)

    $default	reduce using rule 3 (netlistDefs)



state 11

    netlistDef  ->  paramLine .   (rule 4)

    $default	reduce using rule 4 (netlistDef)



state 12

    netlistDef  ->  processLine .   (rule 5)

    $default	reduce using rule 5 (netlistDef)



state 13

    netlistDef  ->  subnet .   (rule 6)

    $default	reduce using rule 6 (netlistDef)



state 14

    subnet  ->  subnetHead . codeBlock   (rule 15)

    '[' 	shift, and go to state 8

    codeBlock	go to state 46
    blockStart	go to state 18



state 15

    subnetHead  ->  subnetKey . ID '[' names ']' '[' subnetParams ']'   (rule 16)

    ID  	shift, and go to state 47



state 16

    netlistDef  ->  codeLine .   (rule 7)

    $default	reduce using rule 7 (netlistDef)



state 17

    codeLine  ->  codeBlock .   (rule 25)

    $default	reduce using rule 25 (codeLine)



state 18

    codeBlock  ->  blockStart . codeLines blockEnd   (rule 31)

    $default	reduce using rule 24 (codeLines)

    codeLines	go to state 48



state 19

    codeLine  ->  elementLine .   (rule 27)

    $default	reduce using rule 27 (codeLine)



state 20

    elementLine  ->  elementHead . '[' names ']' blockStart defs blockEnd   (rule 34)

    '[' 	shift, and go to state 49



state 21

    codeLine  ->  forLine .   (rule 28)

    $default	reduce using rule 28 (codeLine)



state 22

    forLine  ->  forHead . codeBlock   (rule 41)

    '[' 	shift, and go to state 8

    codeBlock	go to state 50
    blockStart	go to state 18



state 23

    codeLine  ->  ifLine .   (rule 29)

    $default	reduce using rule 29 (codeLine)



state 24

    codeLine  ->  def .   (rule 26)

    $default	reduce using rule 26 (codeLine)



state 25

    codeLine  ->  callNode .   (rule 30)

    $default	reduce using rule 30 (codeLine)



state 26

    expr  ->  NOT . expr   (rule 58)

    NOT 	shift, and go to state 26
    ID  	shift, and go to state 27
    INT 	shift, and go to state 28
    FLOAT	shift, and go to state 29
    STRING	shift, and go to state 30
    '-' 	shift, and go to state 31
    '(' 	shift, and go to state 32

    expr	go to state 51



state 27

    expr  ->  ID .   (rule 71)
    expr  ->  ID . '(' optexprs ')'   (rule 72)

    '(' 	shift, and go to state 52

    $default	reduce using rule 71 (expr)



state 28

    expr  ->  INT .   (rule 68)

    $default	reduce using rule 68 (expr)



state 29

    expr  ->  FLOAT .   (rule 69)

    $default	reduce using rule 69 (expr)



state 30

    expr  ->  STRING .   (rule 70)

    $default	reduce using rule 70 (expr)



state 31

    expr  ->  '-' . expr   (rule 57)

    NOT 	shift, and go to state 26
    ID  	shift, and go to state 27
    INT 	shift, and go to state 28
    FLOAT	shift, and go to state 29
    STRING	shift, and go to state 30
    '-' 	shift, and go to state 31
    '(' 	shift, and go to state 32

    expr	go to state 53



state 32

    expr  ->  '(' . expr ')'   (rule 67)

    NOT 	shift, and go to state 26
    ID  	shift, and go to state 27
    INT 	shift, and go to state 28
    FLOAT	shift, and go to state 29
    STRING	shift, and go to state 30
    '-' 	shift, and go to state 31
    '(' 	shift, and go to state 32

    expr	go to state 54



state 33

    ifLine  ->  IF expr . codeLine   (rule 43)
    ifLine  ->  IF expr . codeLine ELSE codeLine   (rule 44)
    expr  ->  expr . '+' expr   (rule 52)
    expr  ->  expr . '-' expr   (rule 53)
    expr  ->  expr . '*' expr   (rule 54)
    expr  ->  expr . '/' expr   (rule 55)
    expr  ->  expr . '^' expr   (rule 56)
    expr  ->  expr . AND expr   (rule 59)
    expr  ->  expr . OR expr   (rule 60)
    expr  ->  expr . EQ expr   (rule 61)
    expr  ->  expr . NEQ expr   (rule 62)
    expr  ->  expr . GT expr   (rule 63)
    expr  ->  expr . LT expr   (rule 64)
    expr  ->  expr . GEQ expr   (rule 65)
    expr  ->  expr . LEQ expr   (rule 66)

    IF  	shift, and go to state 1
    OR  	shift, and go to state 55
    AND 	shift, and go to state 56
    EQ  	shift, and go to state 57
    NEQ 	shift, and go to state 58
    GT  	shift, and go to state 59
    LT  	shift, and go to state 60
    GEQ 	shift, and go to state 61
    LEQ 	shift, and go to state 62
    CALL	shift, and go to state 2
    FOR 	shift, and go to state 6
    ID  	shift, and go to state 7
    '-' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '*' 	shift, and go to state 65
    '/' 	shift, and go to state 66
    '^' 	shift, and go to state 67
    '[' 	shift, and go to state 8

    codeLine	go to state 68
    codeBlock	go to state 17
    blockStart	go to state 18
    elementLine	go to state 19
    elementHead	go to state 20
    forLine	go to state 21
    forHead	go to state 22
    ifLine	go to state 23
    def 	go to state 24
    callNode	go to state 25



state 34

    callNode  ->  CALL ID . '(' optexprs ')'   (rule 73)

    '(' 	shift, and go to state 69



state 35

    param  ->  ID .   (rule 12)
    def  ->  ID . '=' expr   (rule 45)

    '=' 	shift, and go to state 43

    $default	reduce using rule 12 (param)



state 36

    paramLine  ->  PARAM paramList .   (rule 8)
    paramList  ->  paramList . ',' param   (rule 10)

    ',' 	shift, and go to state 70

    $default	reduce using rule 8 (paramLine)



state 37

    paramList  ->  param .   (rule 9)

    $default	reduce using rule 9 (paramList)



state 38

    param  ->  def .   (rule 11)

    $default	reduce using rule 11 (param)



state 39

    processLine  ->  PROCESS ID . '=' blockStart defs blockEnd   (rule 13)
    processLine  ->  PROCESS ID . ':' ID '=' blockStart defs blockEnd   (rule 14)

    '=' 	shift, and go to state 71
    ':' 	shift, and go to state 72



state 40

    forHead  ->  FOR ID . '=' expr ':' expr   (rule 42)

    '=' 	shift, and go to state 73



state 41

    elementHead  ->  ID ID . ID   (rule 36)
    elementHead  ->  ID ID . '*'   (rule 38)
    elementHead  ->  ID ID .   (rule 39)

    ID  	shift, and go to state 74
    '*' 	shift, and go to state 75

    $default	reduce using rule 39 (elementHead)



state 42

    elementHead  ->  ID '*' .   (rule 40)

    $default	reduce using rule 40 (elementHead)



state 43

    def  ->  ID '=' . expr   (rule 45)

    NOT 	shift, and go to state 26
    ID  	shift, and go to state 27
    INT 	shift, and go to state 28
    FLOAT	shift, and go to state 29
    STRING	shift, and go to state 30
    '-' 	shift, and go to state 31
    '(' 	shift, and go to state 32

    expr	go to state 76



state 44

    elementHead  ->  ID '(' . exprs ')' ID ID   (rule 35)
    elementHead  ->  ID '(' . exprs ')' ID '*'   (rule 37)

    NOT 	shift, and go to state 26
    ID  	shift, and go to state 27
    INT 	shift, and go to state 28
    FLOAT	shift, and go to state 29
    STRING	shift, and go to state 30
    '-' 	shift, and go to state 31
    '(' 	shift, and go to state 32

    expr	go to state 77
    exprs	go to state 78



state 45

    netlistDefs  ->  netlistDefs netlistDef .   (rule 2)

    $default	reduce using rule 2 (netlistDefs)



state 46

    subnet  ->  subnetHead codeBlock .   (rule 15)

    $default	reduce using rule 15 (subnet)



state 47

    subnetHead  ->  subnetKey ID . '[' names ']' '[' subnetParams ']'   (rule 16)

    '[' 	shift, and go to state 79



state 48

    codeLines  ->  codeLines . codeLine   (rule 23)
    codeBlock  ->  blockStart codeLines . blockEnd   (rule 31)

    IF  	shift, and go to state 1
    CALL	shift, and go to state 2
    FOR 	shift, and go to state 6
    ID  	shift, and go to state 7
    '[' 	shift, and go to state 8
    ']' 	shift, and go to state 80

    codeLine	go to state 81
    codeBlock	go to state 17
    blockStart	go to state 18
    blockEnd	go to state 82
    elementLine	go to state 19
    elementHead	go to state 20
    forLine	go to state 21
    forHead	go to state 22
    ifLine	go to state 23
    def 	go to state 24
    callNode	go to state 25



state 49

    elementLine  ->  elementHead '[' . names ']' blockStart defs blockEnd   (rule 34)

    $default	reduce using rule 49 (names)

    names	go to state 83



state 50

    forLine  ->  forHead codeBlock .   (rule 41)

    $default	reduce using rule 41 (forLine)



state 51

    expr  ->  expr . '+' expr   (rule 52)
    expr  ->  expr . '-' expr   (rule 53)
    expr  ->  expr . '*' expr   (rule 54)
    expr  ->  expr . '/' expr   (rule 55)
    expr  ->  expr . '^' expr   (rule 56)
    expr  ->  NOT expr .   (rule 58)
    expr  ->  expr . AND expr   (rule 59)
    expr  ->  expr . OR expr   (rule 60)
    expr  ->  expr . EQ expr   (rule 61)
    expr  ->  expr . NEQ expr   (rule 62)
    expr  ->  expr . GT expr   (rule 63)
    expr  ->  expr . LT expr   (rule 64)
    expr  ->  expr . GEQ expr   (rule 65)
    expr  ->  expr . LEQ expr   (rule 66)

    '^' 	shift, and go to state 67

    $default	reduce using rule 58 (expr)



state 52

    expr  ->  ID '(' . optexprs ')'   (rule 72)

    NOT 	shift, and go to state 26
    ID  	shift, and go to state 27
    INT 	shift, and go to state 28
    FLOAT	shift, and go to state 29
    STRING	shift, and go to state 30
    '-' 	shift, and go to state 31
    '(' 	shift, and go to state 32

    $default	reduce using rule 77 (optexprs)

    expr	go to state 77
    exprs	go to state 84
    optexprs	go to state 85



state 53

    expr  ->  expr . '+' expr   (rule 52)
    expr  ->  expr . '-' expr   (rule 53)
    expr  ->  expr . '*' expr   (rule 54)
    expr  ->  expr . '/' expr   (rule 55)
    expr  ->  expr . '^' expr   (rule 56)
    expr  ->  '-' expr .   (rule 57)
    expr  ->  expr . AND expr   (rule 59)
    expr  ->  expr . OR expr   (rule 60)
    expr  ->  expr . EQ expr   (rule 61)
    expr  ->  expr . NEQ expr   (rule 62)
    expr  ->  expr . GT expr   (rule 63)
    expr  ->  expr . LT expr   (rule 64)
    expr  ->  expr . GEQ expr   (rule 65)
    expr  ->  expr . LEQ expr   (rule 66)

    '^' 	shift, and go to state 67

    $default	reduce using rule 57 (expr)



state 54

    expr  ->  expr . '+' expr   (rule 52)
    expr  ->  expr . '-' expr   (rule 53)
    expr  ->  expr . '*' expr   (rule 54)
    expr  ->  expr . '/' expr   (rule 55)
    expr  ->  expr . '^' expr   (rule 56)
    expr  ->  expr . AND expr   (rule 59)
    expr  ->  expr . OR expr   (rule 60)
    expr  ->  expr . EQ expr   (rule 61)
    expr  ->  expr . NEQ expr   (rule 62)
    expr  ->  expr . GT expr   (rule 63)
    expr  ->  expr . LT expr   (rule 64)
    expr  ->  expr . GEQ expr   (rule 65)
    expr  ->  expr . LEQ expr   (rule 66)
    expr  ->  '(' expr . ')'   (rule 67)

    OR  	shift, and go to state 55
    AND 	shift, and go to state 56
    EQ  	shift, and go to state 57
    NEQ 	shift, and go to state 58
    GT  	shift, and go to state 59
    LT  	shift, and go to state 60
    GEQ 	shift, and go to state 61
    LEQ 	shift, and go to state 62
    '-' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '*' 	shift, and go to state 65
    '/' 	shift, and go to state 66
    '^' 	shift, and go to state 67
    ')' 	shift, and go to state 86



state 55

    expr  ->  expr OR . expr   (rule 60)

    NOT 	shift, and go to state 26
    ID  	shift, and go to state 27
    INT 	shift, and go to state 28
    FLOAT	shift, and go to state 29
    STRING	shift, and go to state 30
    '-' 	shift, and go to state 31
    '(' 	shift, and go to state 32

    expr	go to state 87



state 56

    expr  ->  expr AND . expr   (rule 59)

    NOT 	shift, and go to state 26
    ID  	shift, and go to state 27
    INT 	shift, and go to state 28
    FLOAT	shift, and go to state 29
    STRING	shift, and go to state 30
    '-' 	shift, and go to state 31
    '(' 	shift, and go to state 32

    expr	go to state 88



state 57

    expr  ->  expr EQ . expr   (rule 61)

    NOT 	shift, and go to state 26
    ID  	shift, and go to state 27
    INT 	shift, and go to state 28
    FLOAT	shift, and go to state 29
    STRING	shift, and go to state 30
    '-' 	shift, and go to state 31
    '(' 	shift, and go to state 32

    expr	go to state 89



state 58

    expr  ->  expr NEQ . expr   (rule 62)

    NOT 	shift, and go to state 26
    ID  	shift, and go to state 27
    INT 	shift, and go to state 28
    FLOAT	shift, and go to state 29
    STRING	shift, and go to state 30
    '-' 	shift, and go to state 31
    '(' 	shift, and go to state 32

    expr	go to state 90



state 59

    expr  ->  expr GT . expr   (rule 63)

    NOT 	shift, and go to state 26
    ID  	shift, and go to state 27
    INT 	shift, and go to state 28
    FLOAT	shift, and go to state 29
    STRING	shift, and go to state 30
    '-' 	shift, and go to state 31
    '(' 	shift, and go to state 32

    expr	go to state 91



state 60

    expr  ->  expr LT . expr   (rule 64)

    NOT 	shift, and go to state 26
    ID  	shift, and go to state 27
    INT 	shift, and go to state 28
    FLOAT	shift, and go to state 29
    STRING	shift, and go to state 30
    '-' 	shift, and go to state 31
    '(' 	shift, and go to state 32

    expr	go to state 92



state 61

    expr  ->  expr GEQ . expr   (rule 65)

    NOT 	shift, and go to state 26
    ID  	shift, and go to state 27
    INT 	shift, and go to state 28
    FLOAT	shift, and go to state 29
    STRING	shift, and go to state 30
    '-' 	shift, and go to state 31
    '(' 	shift, and go to state 32

    expr	go to state 93



state 62

    expr  ->  expr LEQ . expr   (rule 66)

    NOT 	shift, and go to state 26
    ID  	shift, and go to state 27
    INT 	shift, and go to state 28
    FLOAT	shift, and go to state 29
    STRING	shift, and go to state 30
    '-' 	shift, and go to state 31
    '(' 	shift, and go to state 32

    expr	go to state 94



state 63

    expr  ->  expr '-' . expr   (rule 53)

    NOT 	shift, and go to state 26
    ID  	shift, and go to state 27
    INT 	shift, and go to state 28
    FLOAT	shift, and go to state 29
    STRING	shift, and go to state 30
    '-' 	shift, and go to state 31
    '(' 	shift, and go to state 32

    expr	go to state 95



state 64

    expr  ->  expr '+' . expr   (rule 52)

    NOT 	shift, and go to state 26
    ID  	shift, and go to state 27
    INT 	shift, and go to state 28
    FLOAT	shift, and go to state 29
    STRING	shift, and go to state 30
    '-' 	shift, and go to state 31
    '(' 	shift, and go to state 32

    expr	go to state 96



state 65

    expr  ->  expr '*' . expr   (rule 54)

    NOT 	shift, and go to state 26
    ID  	shift, and go to state 27
    INT 	shift, and go to state 28
    FLOAT	shift, and go to state 29
    STRING	shift, and go to state 30
    '-' 	shift, and go to state 31
    '(' 	shift, and go to state 32

    expr	go to state 97



state 66

    expr  ->  expr '/' . expr   (rule 55)

    NOT 	shift, and go to state 26
    ID  	shift, and go to state 27
    INT 	shift, and go to state 28
    FLOAT	shift, and go to state 29
    STRING	shift, and go to state 30
    '-' 	shift, and go to state 31
    '(' 	shift, and go to state 32

    expr	go to state 98



state 67

    expr  ->  expr '^' . expr   (rule 56)

    NOT 	shift, and go to state 26
    ID  	shift, and go to state 27
    INT 	shift, and go to state 28
    FLOAT	shift, and go to state 29
    STRING	shift, and go to state 30
    '-' 	shift, and go to state 31
    '(' 	shift, and go to state 32

    expr	go to state 99



state 68

    ifLine  ->  IF expr codeLine .   (rule 43)
    ifLine  ->  IF expr codeLine . ELSE codeLine   (rule 44)

    ELSE	shift, and go to state 100

    ELSE	[reduce using rule 43 (ifLine)]
    $default	reduce using rule 43 (ifLine)



state 69

    callNode  ->  CALL ID '(' . optexprs ')'   (rule 73)

    NOT 	shift, and go to state 26
    ID  	shift, and go to state 27
    INT 	shift, and go to state 28
    FLOAT	shift, and go to state 29
    STRING	shift, and go to state 30
    '-' 	shift, and go to state 31
    '(' 	shift, and go to state 32

    $default	reduce using rule 77 (optexprs)

    expr	go to state 77
    exprs	go to state 84
    optexprs	go to state 101



state 70

    paramList  ->  paramList ',' . param   (rule 10)

    ID  	shift, and go to state 35

    param	go to state 102
    def 	go to state 38



state 71

    processLine  ->  PROCESS ID '=' . blockStart defs blockEnd   (rule 13)

    '[' 	shift, and go to state 8

    blockStart	go to state 103



state 72

    processLine  ->  PROCESS ID ':' . ID '=' blockStart defs blockEnd   (rule 14)

    ID  	shift, and go to state 104



state 73

    forHead  ->  FOR ID '=' . expr ':' expr   (rule 42)

    NOT 	shift, and go to state 26
    ID  	shift, and go to state 27
    INT 	shift, and go to state 28
    FLOAT	shift, and go to state 29
    STRING	shift, and go to state 30
    '-' 	shift, and go to state 31
    '(' 	shift, and go to state 32

    expr	go to state 105



state 74

    elementHead  ->  ID ID ID .   (rule 36)

    $default	reduce using rule 36 (elementHead)



state 75

    elementHead  ->  ID ID '*' .   (rule 38)

    $default	reduce using rule 38 (elementHead)



state 76

    def  ->  ID '=' expr .   (rule 45)
    expr  ->  expr . '+' expr   (rule 52)
    expr  ->  expr . '-' expr   (rule 53)
    expr  ->  expr . '*' expr   (rule 54)
    expr  ->  expr . '/' expr   (rule 55)
    expr  ->  expr . '^' expr   (rule 56)
    expr  ->  expr . AND expr   (rule 59)
    expr  ->  expr . OR expr   (rule 60)
    expr  ->  expr . EQ expr   (rule 61)
    expr  ->  expr . NEQ expr   (rule 62)
    expr  ->  expr . GT expr   (rule 63)
    expr  ->  expr . LT expr   (rule 64)
    expr  ->  expr . GEQ expr   (rule 65)
    expr  ->  expr . LEQ expr   (rule 66)

    OR  	shift, and go to state 55
    AND 	shift, and go to state 56
    EQ  	shift, and go to state 57
    NEQ 	shift, and go to state 58
    GT  	shift, and go to state 59
    LT  	shift, and go to state 60
    GEQ 	shift, and go to state 61
    LEQ 	shift, and go to state 62
    '-' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '*' 	shift, and go to state 65
    '/' 	shift, and go to state 66
    '^' 	shift, and go to state 67

    $default	reduce using rule 45 (def)



state 77

    expr  ->  expr . '+' expr   (rule 52)
    expr  ->  expr . '-' expr   (rule 53)
    expr  ->  expr . '*' expr   (rule 54)
    expr  ->  expr . '/' expr   (rule 55)
    expr  ->  expr . '^' expr   (rule 56)
    expr  ->  expr . AND expr   (rule 59)
    expr  ->  expr . OR expr   (rule 60)
    expr  ->  expr . EQ expr   (rule 61)
    expr  ->  expr . NEQ expr   (rule 62)
    expr  ->  expr . GT expr   (rule 63)
    expr  ->  expr . LT expr   (rule 64)
    expr  ->  expr . GEQ expr   (rule 65)
    expr  ->  expr . LEQ expr   (rule 66)
    exprs  ->  expr .   (rule 75)

    OR  	shift, and go to state 55
    AND 	shift, and go to state 56
    EQ  	shift, and go to state 57
    NEQ 	shift, and go to state 58
    GT  	shift, and go to state 59
    LT  	shift, and go to state 60
    GEQ 	shift, and go to state 61
    LEQ 	shift, and go to state 62
    '-' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '*' 	shift, and go to state 65
    '/' 	shift, and go to state 66
    '^' 	shift, and go to state 67

    $default	reduce using rule 75 (exprs)



state 78

    elementHead  ->  ID '(' exprs . ')' ID ID   (rule 35)
    elementHead  ->  ID '(' exprs . ')' ID '*'   (rule 37)
    exprs  ->  exprs . ',' expr   (rule 74)

    ',' 	shift, and go to state 106
    ')' 	shift, and go to state 107



state 79

    subnetHead  ->  subnetKey ID '[' . names ']' '[' subnetParams ']'   (rule 16)

    $default	reduce using rule 49 (names)

    names	go to state 108



state 80

    blockEnd  ->  ']' .   (rule 33)

    $default	reduce using rule 33 (blockEnd)



state 81

    codeLines  ->  codeLines codeLine .   (rule 23)

    $default	reduce using rule 23 (codeLines)



state 82

    codeBlock  ->  blockStart codeLines blockEnd .   (rule 31)

    $default	reduce using rule 31 (codeBlock)



state 83

    elementLine  ->  elementHead '[' names . ']' blockStart defs blockEnd   (rule 34)
    names  ->  names . name   (rule 48)

    ID  	shift, and go to state 109
    ']' 	shift, and go to state 110

    name	go to state 111



state 84

    exprs  ->  exprs . ',' expr   (rule 74)
    optexprs  ->  exprs .   (rule 76)

    ',' 	shift, and go to state 106

    $default	reduce using rule 76 (optexprs)



state 85

    expr  ->  ID '(' optexprs . ')'   (rule 72)

    ')' 	shift, and go to state 112



state 86

    expr  ->  '(' expr ')' .   (rule 67)

    $default	reduce using rule 67 (expr)



state 87

    expr  ->  expr . '+' expr   (rule 52)
    expr  ->  expr . '-' expr   (rule 53)
    expr  ->  expr . '*' expr   (rule 54)
    expr  ->  expr . '/' expr   (rule 55)
    expr  ->  expr . '^' expr   (rule 56)
    expr  ->  expr . AND expr   (rule 59)
    expr  ->  expr . OR expr   (rule 60)
    expr  ->  expr OR expr .   (rule 60)
    expr  ->  expr . EQ expr   (rule 61)
    expr  ->  expr . NEQ expr   (rule 62)
    expr  ->  expr . GT expr   (rule 63)
    expr  ->  expr . LT expr   (rule 64)
    expr  ->  expr . GEQ expr   (rule 65)
    expr  ->  expr . LEQ expr   (rule 66)

    AND 	shift, and go to state 56
    EQ  	shift, and go to state 57
    NEQ 	shift, and go to state 58
    GT  	shift, and go to state 59
    LT  	shift, and go to state 60
    GEQ 	shift, and go to state 61
    LEQ 	shift, and go to state 62
    '-' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '*' 	shift, and go to state 65
    '/' 	shift, and go to state 66
    '^' 	shift, and go to state 67

    $default	reduce using rule 60 (expr)



state 88

    expr  ->  expr . '+' expr   (rule 52)
    expr  ->  expr . '-' expr   (rule 53)
    expr  ->  expr . '*' expr   (rule 54)
    expr  ->  expr . '/' expr   (rule 55)
    expr  ->  expr . '^' expr   (rule 56)
    expr  ->  expr . AND expr   (rule 59)
    expr  ->  expr AND expr .   (rule 59)
    expr  ->  expr . OR expr   (rule 60)
    expr  ->  expr . EQ expr   (rule 61)
    expr  ->  expr . NEQ expr   (rule 62)
    expr  ->  expr . GT expr   (rule 63)
    expr  ->  expr . LT expr   (rule 64)
    expr  ->  expr . GEQ expr   (rule 65)
    expr  ->  expr . LEQ expr   (rule 66)

    EQ  	shift, and go to state 57
    NEQ 	shift, and go to state 58
    GT  	shift, and go to state 59
    LT  	shift, and go to state 60
    GEQ 	shift, and go to state 61
    LEQ 	shift, and go to state 62
    '-' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '*' 	shift, and go to state 65
    '/' 	shift, and go to state 66
    '^' 	shift, and go to state 67

    $default	reduce using rule 59 (expr)



state 89

    expr  ->  expr . '+' expr   (rule 52)
    expr  ->  expr . '-' expr   (rule 53)
    expr  ->  expr . '*' expr   (rule 54)
    expr  ->  expr . '/' expr   (rule 55)
    expr  ->  expr . '^' expr   (rule 56)
    expr  ->  expr . AND expr   (rule 59)
    expr  ->  expr . OR expr   (rule 60)
    expr  ->  expr . EQ expr   (rule 61)
    expr  ->  expr EQ expr .   (rule 61)
    expr  ->  expr . NEQ expr   (rule 62)
    expr  ->  expr . GT expr   (rule 63)
    expr  ->  expr . LT expr   (rule 64)
    expr  ->  expr . GEQ expr   (rule 65)
    expr  ->  expr . LEQ expr   (rule 66)

    '-' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '*' 	shift, and go to state 65
    '/' 	shift, and go to state 66
    '^' 	shift, and go to state 67

    $default	reduce using rule 61 (expr)



state 90

    expr  ->  expr . '+' expr   (rule 52)
    expr  ->  expr . '-' expr   (rule 53)
    expr  ->  expr . '*' expr   (rule 54)
    expr  ->  expr . '/' expr   (rule 55)
    expr  ->  expr . '^' expr   (rule 56)
    expr  ->  expr . AND expr   (rule 59)
    expr  ->  expr . OR expr   (rule 60)
    expr  ->  expr . EQ expr   (rule 61)
    expr  ->  expr . NEQ expr   (rule 62)
    expr  ->  expr NEQ expr .   (rule 62)
    expr  ->  expr . GT expr   (rule 63)
    expr  ->  expr . LT expr   (rule 64)
    expr  ->  expr . GEQ expr   (rule 65)
    expr  ->  expr . LEQ expr   (rule 66)

    '-' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '*' 	shift, and go to state 65
    '/' 	shift, and go to state 66
    '^' 	shift, and go to state 67

    $default	reduce using rule 62 (expr)



state 91

    expr  ->  expr . '+' expr   (rule 52)
    expr  ->  expr . '-' expr   (rule 53)
    expr  ->  expr . '*' expr   (rule 54)
    expr  ->  expr . '/' expr   (rule 55)
    expr  ->  expr . '^' expr   (rule 56)
    expr  ->  expr . AND expr   (rule 59)
    expr  ->  expr . OR expr   (rule 60)
    expr  ->  expr . EQ expr   (rule 61)
    expr  ->  expr . NEQ expr   (rule 62)
    expr  ->  expr . GT expr   (rule 63)
    expr  ->  expr GT expr .   (rule 63)
    expr  ->  expr . LT expr   (rule 64)
    expr  ->  expr . GEQ expr   (rule 65)
    expr  ->  expr . LEQ expr   (rule 66)

    '-' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '*' 	shift, and go to state 65
    '/' 	shift, and go to state 66
    '^' 	shift, and go to state 67

    $default	reduce using rule 63 (expr)



state 92

    expr  ->  expr . '+' expr   (rule 52)
    expr  ->  expr . '-' expr   (rule 53)
    expr  ->  expr . '*' expr   (rule 54)
    expr  ->  expr . '/' expr   (rule 55)
    expr  ->  expr . '^' expr   (rule 56)
    expr  ->  expr . AND expr   (rule 59)
    expr  ->  expr . OR expr   (rule 60)
    expr  ->  expr . EQ expr   (rule 61)
    expr  ->  expr . NEQ expr   (rule 62)
    expr  ->  expr . GT expr   (rule 63)
    expr  ->  expr . LT expr   (rule 64)
    expr  ->  expr LT expr .   (rule 64)
    expr  ->  expr . GEQ expr   (rule 65)
    expr  ->  expr . LEQ expr   (rule 66)

    '-' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '*' 	shift, and go to state 65
    '/' 	shift, and go to state 66
    '^' 	shift, and go to state 67

    $default	reduce using rule 64 (expr)



state 93

    expr  ->  expr . '+' expr   (rule 52)
    expr  ->  expr . '-' expr   (rule 53)
    expr  ->  expr . '*' expr   (rule 54)
    expr  ->  expr . '/' expr   (rule 55)
    expr  ->  expr . '^' expr   (rule 56)
    expr  ->  expr . AND expr   (rule 59)
    expr  ->  expr . OR expr   (rule 60)
    expr  ->  expr . EQ expr   (rule 61)
    expr  ->  expr . NEQ expr   (rule 62)
    expr  ->  expr . GT expr   (rule 63)
    expr  ->  expr . LT expr   (rule 64)
    expr  ->  expr . GEQ expr   (rule 65)
    expr  ->  expr GEQ expr .   (rule 65)
    expr  ->  expr . LEQ expr   (rule 66)

    '-' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '*' 	shift, and go to state 65
    '/' 	shift, and go to state 66
    '^' 	shift, and go to state 67

    $default	reduce using rule 65 (expr)



state 94

    expr  ->  expr . '+' expr   (rule 52)
    expr  ->  expr . '-' expr   (rule 53)
    expr  ->  expr . '*' expr   (rule 54)
    expr  ->  expr . '/' expr   (rule 55)
    expr  ->  expr . '^' expr   (rule 56)
    expr  ->  expr . AND expr   (rule 59)
    expr  ->  expr . OR expr   (rule 60)
    expr  ->  expr . EQ expr   (rule 61)
    expr  ->  expr . NEQ expr   (rule 62)
    expr  ->  expr . GT expr   (rule 63)
    expr  ->  expr . LT expr   (rule 64)
    expr  ->  expr . GEQ expr   (rule 65)
    expr  ->  expr . LEQ expr   (rule 66)
    expr  ->  expr LEQ expr .   (rule 66)

    '-' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '*' 	shift, and go to state 65
    '/' 	shift, and go to state 66
    '^' 	shift, and go to state 67

    $default	reduce using rule 66 (expr)



state 95

    expr  ->  expr . '+' expr   (rule 52)
    expr  ->  expr . '-' expr   (rule 53)
    expr  ->  expr '-' expr .   (rule 53)
    expr  ->  expr . '*' expr   (rule 54)
    expr  ->  expr . '/' expr   (rule 55)
    expr  ->  expr . '^' expr   (rule 56)
    expr  ->  expr . AND expr   (rule 59)
    expr  ->  expr . OR expr   (rule 60)
    expr  ->  expr . EQ expr   (rule 61)
    expr  ->  expr . NEQ expr   (rule 62)
    expr  ->  expr . GT expr   (rule 63)
    expr  ->  expr . LT expr   (rule 64)
    expr  ->  expr . GEQ expr   (rule 65)
    expr  ->  expr . LEQ expr   (rule 66)

    '*' 	shift, and go to state 65
    '/' 	shift, and go to state 66
    '^' 	shift, and go to state 67

    $default	reduce using rule 53 (expr)



state 96

    expr  ->  expr . '+' expr   (rule 52)
    expr  ->  expr '+' expr .   (rule 52)
    expr  ->  expr . '-' expr   (rule 53)
    expr  ->  expr . '*' expr   (rule 54)
    expr  ->  expr . '/' expr   (rule 55)
    expr  ->  expr . '^' expr   (rule 56)
    expr  ->  expr . AND expr   (rule 59)
    expr  ->  expr . OR expr   (rule 60)
    expr  ->  expr . EQ expr   (rule 61)
    expr  ->  expr . NEQ expr   (rule 62)
    expr  ->  expr . GT expr   (rule 63)
    expr  ->  expr . LT expr   (rule 64)
    expr  ->  expr . GEQ expr   (rule 65)
    expr  ->  expr . LEQ expr   (rule 66)

    '*' 	shift, and go to state 65
    '/' 	shift, and go to state 66
    '^' 	shift, and go to state 67

    $default	reduce using rule 52 (expr)



state 97

    expr  ->  expr . '+' expr   (rule 52)
    expr  ->  expr . '-' expr   (rule 53)
    expr  ->  expr . '*' expr   (rule 54)
    expr  ->  expr '*' expr .   (rule 54)
    expr  ->  expr . '/' expr   (rule 55)
    expr  ->  expr . '^' expr   (rule 56)
    expr  ->  expr . AND expr   (rule 59)
    expr  ->  expr . OR expr   (rule 60)
    expr  ->  expr . EQ expr   (rule 61)
    expr  ->  expr . NEQ expr   (rule 62)
    expr  ->  expr . GT expr   (rule 63)
    expr  ->  expr . LT expr   (rule 64)
    expr  ->  expr . GEQ expr   (rule 65)
    expr  ->  expr . LEQ expr   (rule 66)

    '^' 	shift, and go to state 67

    $default	reduce using rule 54 (expr)



state 98

    expr  ->  expr . '+' expr   (rule 52)
    expr  ->  expr . '-' expr   (rule 53)
    expr  ->  expr . '*' expr   (rule 54)
    expr  ->  expr . '/' expr   (rule 55)
    expr  ->  expr '/' expr .   (rule 55)
    expr  ->  expr . '^' expr   (rule 56)
    expr  ->  expr . AND expr   (rule 59)
    expr  ->  expr . OR expr   (rule 60)
    expr  ->  expr . EQ expr   (rule 61)
    expr  ->  expr . NEQ expr   (rule 62)
    expr  ->  expr . GT expr   (rule 63)
    expr  ->  expr . LT expr   (rule 64)
    expr  ->  expr . GEQ expr   (rule 65)
    expr  ->  expr . LEQ expr   (rule 66)

    '^' 	shift, and go to state 67

    $default	reduce using rule 55 (expr)



state 99

    expr  ->  expr . '+' expr   (rule 52)
    expr  ->  expr . '-' expr   (rule 53)
    expr  ->  expr . '*' expr   (rule 54)
    expr  ->  expr . '/' expr   (rule 55)
    expr  ->  expr . '^' expr   (rule 56)
    expr  ->  expr '^' expr .   (rule 56)
    expr  ->  expr . AND expr   (rule 59)
    expr  ->  expr . OR expr   (rule 60)
    expr  ->  expr . EQ expr   (rule 61)
    expr  ->  expr . NEQ expr   (rule 62)
    expr  ->  expr . GT expr   (rule 63)
    expr  ->  expr . LT expr   (rule 64)
    expr  ->  expr . GEQ expr   (rule 65)
    expr  ->  expr . LEQ expr   (rule 66)


    $default	reduce using rule 56 (expr)



state 100

    ifLine  ->  IF expr codeLine ELSE . codeLine   (rule 44)

    IF  	shift, and go to state 1
    CALL	shift, and go to state 2
    FOR 	shift, and go to state 6
    ID  	shift, and go to state 7
    '[' 	shift, and go to state 8

    codeLine	go to state 113
    codeBlock	go to state 17
    blockStart	go to state 18
    elementLine	go to state 19
    elementHead	go to state 20
    forLine	go to state 21
    forHead	go to state 22
    ifLine	go to state 23
    def 	go to state 24
    callNode	go to state 25



state 101

    callNode  ->  CALL ID '(' optexprs . ')'   (rule 73)

    ')' 	shift, and go to state 114



state 102

    paramList  ->  paramList ',' param .   (rule 10)

    $default	reduce using rule 10 (paramList)



state 103

    processLine  ->  PROCESS ID '=' blockStart . defs blockEnd   (rule 13)

    $default	reduce using rule 47 (defs)

    defs	go to state 115



state 104

    processLine  ->  PROCESS ID ':' ID . '=' blockStart defs blockEnd   (rule 14)

    '=' 	shift, and go to state 116



state 105

    forHead  ->  FOR ID '=' expr . ':' expr   (rule 42)
    expr  ->  expr . '+' expr   (rule 52)
    expr  ->  expr . '-' expr   (rule 53)
    expr  ->  expr . '*' expr   (rule 54)
    expr  ->  expr . '/' expr   (rule 55)
    expr  ->  expr . '^' expr   (rule 56)
    expr  ->  expr . AND expr   (rule 59)
    expr  ->  expr . OR expr   (rule 60)
    expr  ->  expr . EQ expr   (rule 61)
    expr  ->  expr . NEQ expr   (rule 62)
    expr  ->  expr . GT expr   (rule 63)
    expr  ->  expr . LT expr   (rule 64)
    expr  ->  expr . GEQ expr   (rule 65)
    expr  ->  expr . LEQ expr   (rule 66)

    OR  	shift, and go to state 55
    AND 	shift, and go to state 56
    EQ  	shift, and go to state 57
    NEQ 	shift, and go to state 58
    GT  	shift, and go to state 59
    LT  	shift, and go to state 60
    GEQ 	shift, and go to state 61
    LEQ 	shift, and go to state 62
    '-' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '*' 	shift, and go to state 65
    '/' 	shift, and go to state 66
    '^' 	shift, and go to state 67
    ':' 	shift, and go to state 117



state 106

    exprs  ->  exprs ',' . expr   (rule 74)

    NOT 	shift, and go to state 26
    ID  	shift, and go to state 27
    INT 	shift, and go to state 28
    FLOAT	shift, and go to state 29
    STRING	shift, and go to state 30
    '-' 	shift, and go to state 31
    '(' 	shift, and go to state 32

    expr	go to state 118



state 107

    elementHead  ->  ID '(' exprs ')' . ID ID   (rule 35)
    elementHead  ->  ID '(' exprs ')' . ID '*'   (rule 37)

    ID  	shift, and go to state 119



state 108

    subnetHead  ->  subnetKey ID '[' names . ']' '[' subnetParams ']'   (rule 16)
    names  ->  names . name   (rule 48)

    ID  	shift, and go to state 109
    ']' 	shift, and go to state 120

    name	go to state 111



state 109

    name  ->  ID .   (rule 50)
    name  ->  ID . '(' exprs ')'   (rule 51)

    '(' 	shift, and go to state 121

    $default	reduce using rule 50 (name)



state 110

    elementLine  ->  elementHead '[' names ']' . blockStart defs blockEnd   (rule 34)

    '[' 	shift, and go to state 8

    blockStart	go to state 122



state 111

    names  ->  names name .   (rule 48)

    $default	reduce using rule 48 (names)



state 112

    expr  ->  ID '(' optexprs ')' .   (rule 72)

    $default	reduce using rule 72 (expr)



state 113

    ifLine  ->  IF expr codeLine ELSE codeLine .   (rule 44)

    $default	reduce using rule 44 (ifLine)



state 114

    callNode  ->  CALL ID '(' optexprs ')' .   (rule 73)

    $default	reduce using rule 73 (callNode)



state 115

    processLine  ->  PROCESS ID '=' blockStart defs . blockEnd   (rule 13)
    defs  ->  defs . def   (rule 46)

    ID  	shift, and go to state 123
    ']' 	shift, and go to state 80

    blockEnd	go to state 124
    def 	go to state 125



state 116

    processLine  ->  PROCESS ID ':' ID '=' . blockStart defs blockEnd   (rule 14)

    '[' 	shift, and go to state 8

    blockStart	go to state 126



state 117

    forHead  ->  FOR ID '=' expr ':' . expr   (rule 42)

    NOT 	shift, and go to state 26
    ID  	shift, and go to state 27
    INT 	shift, and go to state 28
    FLOAT	shift, and go to state 29
    STRING	shift, and go to state 30
    '-' 	shift, and go to state 31
    '(' 	shift, and go to state 32

    expr	go to state 127



state 118

    expr  ->  expr . '+' expr   (rule 52)
    expr  ->  expr . '-' expr   (rule 53)
    expr  ->  expr . '*' expr   (rule 54)
    expr  ->  expr . '/' expr   (rule 55)
    expr  ->  expr . '^' expr   (rule 56)
    expr  ->  expr . AND expr   (rule 59)
    expr  ->  expr . OR expr   (rule 60)
    expr  ->  expr . EQ expr   (rule 61)
    expr  ->  expr . NEQ expr   (rule 62)
    expr  ->  expr . GT expr   (rule 63)
    expr  ->  expr . LT expr   (rule 64)
    expr  ->  expr . GEQ expr   (rule 65)
    expr  ->  expr . LEQ expr   (rule 66)
    exprs  ->  exprs ',' expr .   (rule 74)

    OR  	shift, and go to state 55
    AND 	shift, and go to state 56
    EQ  	shift, and go to state 57
    NEQ 	shift, and go to state 58
    GT  	shift, and go to state 59
    LT  	shift, and go to state 60
    GEQ 	shift, and go to state 61
    LEQ 	shift, and go to state 62
    '-' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '*' 	shift, and go to state 65
    '/' 	shift, and go to state 66
    '^' 	shift, and go to state 67

    $default	reduce using rule 74 (exprs)



state 119

    elementHead  ->  ID '(' exprs ')' ID . ID   (rule 35)
    elementHead  ->  ID '(' exprs ')' ID . '*'   (rule 37)

    ID  	shift, and go to state 128
    '*' 	shift, and go to state 129



state 120

    subnetHead  ->  subnetKey ID '[' names ']' . '[' subnetParams ']'   (rule 16)

    '[' 	shift, and go to state 130



state 121

    name  ->  ID '(' . exprs ')'   (rule 51)

    NOT 	shift, and go to state 26
    ID  	shift, and go to state 27
    INT 	shift, and go to state 28
    FLOAT	shift, and go to state 29
    STRING	shift, and go to state 30
    '-' 	shift, and go to state 31
    '(' 	shift, and go to state 32

    expr	go to state 77
    exprs	go to state 131



state 122

    elementLine  ->  elementHead '[' names ']' blockStart . defs blockEnd   (rule 34)

    $default	reduce using rule 47 (defs)

    defs	go to state 132



state 123

    def  ->  ID . '=' expr   (rule 45)

    '=' 	shift, and go to state 43



state 124

    processLine  ->  PROCESS ID '=' blockStart defs blockEnd .   (rule 13)

    $default	reduce using rule 13 (processLine)



state 125

    defs  ->  defs def .   (rule 46)

    $default	reduce using rule 46 (defs)



state 126

    processLine  ->  PROCESS ID ':' ID '=' blockStart . defs blockEnd   (rule 14)

    $default	reduce using rule 47 (defs)

    defs	go to state 133



state 127

    forHead  ->  FOR ID '=' expr ':' expr .   (rule 42)
    expr  ->  expr . '+' expr   (rule 52)
    expr  ->  expr . '-' expr   (rule 53)
    expr  ->  expr . '*' expr   (rule 54)
    expr  ->  expr . '/' expr   (rule 55)
    expr  ->  expr . '^' expr   (rule 56)
    expr  ->  expr . AND expr   (rule 59)
    expr  ->  expr . OR expr   (rule 60)
    expr  ->  expr . EQ expr   (rule 61)
    expr  ->  expr . NEQ expr   (rule 62)
    expr  ->  expr . GT expr   (rule 63)
    expr  ->  expr . LT expr   (rule 64)
    expr  ->  expr . GEQ expr   (rule 65)
    expr  ->  expr . LEQ expr   (rule 66)

    OR  	shift, and go to state 55
    AND 	shift, and go to state 56
    EQ  	shift, and go to state 57
    NEQ 	shift, and go to state 58
    GT  	shift, and go to state 59
    LT  	shift, and go to state 60
    GEQ 	shift, and go to state 61
    LEQ 	shift, and go to state 62
    '-' 	shift, and go to state 63
    '+' 	shift, and go to state 64
    '*' 	shift, and go to state 65
    '/' 	shift, and go to state 66
    '^' 	shift, and go to state 67

    $default	reduce using rule 42 (forHead)



state 128

    elementHead  ->  ID '(' exprs ')' ID ID .   (rule 35)

    $default	reduce using rule 35 (elementHead)



state 129

    elementHead  ->  ID '(' exprs ')' ID '*' .   (rule 37)

    $default	reduce using rule 37 (elementHead)



state 130

    subnetHead  ->  subnetKey ID '[' names ']' '[' . subnetParams ']'   (rule 16)

    $default	reduce using rule 19 (subnetParams)

    subnetParams	go to state 134



state 131

    name  ->  ID '(' exprs . ')'   (rule 51)
    exprs  ->  exprs . ',' expr   (rule 74)

    ',' 	shift, and go to state 106
    ')' 	shift, and go to state 135



state 132

    elementLine  ->  elementHead '[' names ']' blockStart defs . blockEnd   (rule 34)
    defs  ->  defs . def   (rule 46)

    ID  	shift, and go to state 123
    ']' 	shift, and go to state 80

    blockEnd	go to state 136
    def 	go to state 125



state 133

    processLine  ->  PROCESS ID ':' ID '=' blockStart defs . blockEnd   (rule 14)
    defs  ->  defs . def   (rule 46)

    ID  	shift, and go to state 123
    ']' 	shift, and go to state 80

    blockEnd	go to state 137
    def 	go to state 125



state 134

    subnetHead  ->  subnetKey ID '[' names ']' '[' subnetParams . ']'   (rule 16)
    subnetParams  ->  subnetParams . subnetParam   (rule 18)

    ID  	shift, and go to state 138
    ']' 	shift, and go to state 139

    subnetParam	go to state 140
    def 	go to state 141



state 135

    name  ->  ID '(' exprs ')' .   (rule 51)

    $default	reduce using rule 51 (name)



state 136

    elementLine  ->  elementHead '[' names ']' blockStart defs blockEnd .   (rule 34)

    $default	reduce using rule 34 (elementLine)



state 137

    processLine  ->  PROCESS ID ':' ID '=' blockStart defs blockEnd .   (rule 14)

    $default	reduce using rule 14 (processLine)



state 138

    subnetParam  ->  ID . '=' '*'   (rule 21)
    subnetParam  ->  ID . '=' '?'   (rule 22)
    def  ->  ID . '=' expr   (rule 45)

    '=' 	shift, and go to state 142



state 139

    subnetHead  ->  subnetKey ID '[' names ']' '[' subnetParams ']' .   (rule 16)

    $default	reduce using rule 16 (subnetHead)



state 140

    subnetParams  ->  subnetParams subnetParam .   (rule 18)

    $default	reduce using rule 18 (subnetParams)



state 141

    subnetParam  ->  def .   (rule 20)

    $default	reduce using rule 20 (subnetParam)



state 142

    subnetParam  ->  ID '=' . '*'   (rule 21)
    subnetParam  ->  ID '=' . '?'   (rule 22)
    def  ->  ID '=' . expr   (rule 45)

    NOT 	shift, and go to state 26
    ID  	shift, and go to state 27
    INT 	shift, and go to state 28
    FLOAT	shift, and go to state 29
    STRING	shift, and go to state 30
    '-' 	shift, and go to state 31
    '*' 	shift, and go to state 143
    '?' 	shift, and go to state 144
    '(' 	shift, and go to state 32

    expr	go to state 76



state 143

    subnetParam  ->  ID '=' '*' .   (rule 21)

    $default	reduce using rule 21 (subnetParam)



state 144

    subnetParam  ->  ID '=' '?' .   (rule 22)

    $default	reduce using rule 22 (subnetParam)



state 145

    $   	go to state 146



state 146

    $   	go to state 147



state 147

    $default	accept
